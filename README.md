# modelsim-unittest-framework
A simple unit test framework for Model Sim which allows for the generation of .do files which rigorously tests Verilog projects.

### How to Use the Tool
Begin by writing a .txt file containing your unit test (see below for unit test format). Next, run the msimunitgen.py file, passing the relative path and name of the .txt file in as a single argument. If there are no errors, then a .do file will be generated. Run this .do file in Model Sim to test your Verilog project.

To avoid having to manually analyze the output square-wave in Model Sim, the generated .do file is formatted to produce an output .txt file when run in Model Sim. Run msim_unittest.py on this output file, passing in the relative path and name of the .txt file in as a single argument. This will automatically evaluate the results of your test cases, and report a summary back to you.  

### How to Write the Unit Test File
The unit test text file was designed to be intuitive and easy to use. On a macro level, it is composed of different types of "blocks", which are represented with the curly braces "{ }". Inside of these block are statements, where each statement must end with a semicolon. The types of blocks are detailed below.

#### The Meta Block
At the top of the file a meta block is declared using the **meta** keyword, which tells the generator information regarding other files that the generated .do file will have to interact with. An example meta block can be seen below:

~~~
meta {
    vfile = input.v;				# Required
    vmodule = module;				# Required
    genfile = unittests.do;			
    logfile = outputfile.txt;		
    log {/*};
    add wave {/*};
}
~~~
It contains 2 required assignments and 2 optional assignments, which detail the following information:

* **vfile**: the Verilog file to be tested
* **vmodule**: the top level module of the Verilog file
* **genfile**: the name which will be given to the generated .do file (defaults to "out.do")
* **logfile**: the name which will be given to the file generated by Model Sim containing the results of the test (defaults to "output.txt")

Any other statements in the meta block will be written directly to the .do file. Two instances of this can be seen in the above example, where "log {/\*}" and "add wave {/\*}" will be written as-is to the .do file.

#### The Test Block
##### Basics
Unit tests are organized into test blocks. A test block is declared using the **test** keyword followed by the name of the test (which cannot contain spaces). An example test block can be found below:

~~~~
test my_test {
	# Set the inputs to 1010
	INPUT[3] = 1;
    INPUT[2] = 0;
    INPUT[1] = 1;
    INPUT[0] = 0;
	
    # assert the output is 11
    assert OUPUT[1] == 1;
    assert OUPUT[0] == 1;
}
~~~~

Test blocks contain assignment statements, which will force the given input variable to take on the specified binary value, as well as assert statements, which check the value of output variables.

##### Simultaneous Assignment

In order to simplify the life of the tester, there are several shorthand ways to write an equivalent test as above:

~~~~
test my_test_shorthand1 {
	# Set the inputs to 1010
	INPUT[3:0] = 1010;
	
    # assert the output is 11
    assert OUPUT[1:0] == 1;
}
~~~~

As you can see, we can assign multiple indexed variables in a single line. Note that there is two ways to do this:

* specify a value for each variable, as seen with "INPUT[3:0] = 1010"
* or specify the same value for each variable, as seen with "OUTPUT[1:0] == 1"

Note: the order of indexing matters, and INPUT[0:3] is the reverse of INPUT[3:0]

##### bin() Function

When it is more intuitive to specify the value of a collection of variables with the value that they represent (such as a hex or decimal value, or an equation), we can use the **bin()** function. See below:

~~~~
test my_test_shorthand2 {
	# Set the inputs to 1010, which is equivalent to A in hexadecimal
	INPUT[3:0] = bin(0xA, 4);
    
    # Or using decimal notation (produces same result as above)
    INPUT[3:0] = bin(10, 4);
	
    # assert the output is 11
    assert OUPUT[1:0] == 1;
}
~~~~

Here we can see that the bin() function takes two arguments. The first is either a hexadecimal value (prefixed with "0x"), a decimal value, or even an equation (such as 1\*2 + 3). The second argument is the number of bits that the resulting binary number should have. Pay attention when choosing this argument to avoid an overflow error.  

#### The For Block
The for block is used to repeat the same test with different indexable variables. It must be declared within a test block by using the **for** keyword, and it can be nested in other for blocks. An example can be seen below:

~~~~
test for_example {
	INPUT[7:4] = 1010;
    
    for i in [0:15] {
    	INPUT[3:0] = bin(i, 4);
        assert OUTPUT == bin(1/8, 2);
    }
}
~~~~

The for block requires a looping variable (in this case "i"), and a looping range described using square brackets [ ] (in this case "[0:15]"). The looping range is inclusive, and order-sensitive, meaning "[0:15]" loops from 0 to 15, while "[15:0]" loops from 15 to 0.

#### The Permute Block
The permute block is declared using the **permute** keyword, and must be declared within a test block. It cannot be nested in other permute blocks. It is similar to the for block, but does not give the user the option to specify variable values - instead it iterates over every possible permutation of the marked variables. It is used to for test cases when the value of certain input variables should have no input on the output. An example is seen below:

````
test permute_example {
	SELECT[1:0] = 0;
    
	permute {
    	ARBITRARY[2:0] = *;
    	INPUT[3:1] = *;
        INPUT[0] = 1;
        assert OUTPUT = 1;
    }
}
````

In this example, the values if "ARBITRARY[2:0]" and "INPUT[3:1]" will be set to every possible binary permutation, with the assert statement being evaluated after each permutation (since we are assigning 3+4 = 7 variables, this will result in 2^7 = 128 permutations). This can be useful for testing modules such as multiplexers, where only one input should affect the output (the selected input), and the other inputs should have no affect.